# {{- if and .Values.k6.enabled (eq .Values.k6.enabled true) }}
apiVersion: v1
kind: ServiceAccount
metadata:
  name: vault-sa
  namespace: default
---
apiVersion: v1
kind: Secret
metadata:
  name: vault-sa-secret
  annotations:
    kubernetes.io/service-account.name: vault-sa
  namespace: default
type: kubernetes.io/service-account-token
---
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: secret-creator-role
  namespace: default
rules:
  - apiGroups: [""]
    resources: ["secrets"]
    verbs: ["create", "delete", "get", "list"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: secret-creator-rolebinding
  namespace: default
subjects:
  - kind: ServiceAccount
    name: vault-sa
roleRef:
  kind: Role
  name: secret-creator-role
  apiGroup: rbac.authorization.k8s.io
---
apiVersion: batch/v1
kind: Job
metadata:
  name: bearer-token-generator
  namespace: default
spec:
  template:
    spec:
      serviceAccountName: vault-sa
      restartPolicy: Never
      containers:
        - name: vault-client
          image: bitnami/minideb:latest
          imagePullPolicy: IfNotPresent
          command: ["/bin/bash", "-c"]
          args:
            - |
              set -e

              echo "[*] Installing dependencies..."
              apt-get update && apt-get install -y curl jq ca-certificates
              KUBECTL_VERSION=$(curl -sL https://dl.k8s.io/release/stable.txt)
              echo "Downloading kubectl version: $KUBECTL_VERSION"

              curl -sL -o kubectl "https://dl.k8s.io/release/${KUBECTL_VERSION}/bin/linux/amd64/kubectl"
              chmod +x kubectl
              mv kubectl /usr/local/bin/kubectl
              echo "kubectl installed successfully."
              kubectl version --client

              echo "[*] Starting Vault authentication..."

              SA_TOKEN_PATH="/vault-token/token"
              VAULT_ADDR="http://vault.vault.svc.cluster.local:8200"

              echo "[*] Reading Kubernetes service account token..."
              JWT_TOKEN=$(cat "$SA_TOKEN_PATH")
              echo "[*] JWT token read successfully."

              echo "[*] Logging into Vault with Kubernetes auth..."
              LOGIN_RESPONSE=$(curl --silent --request POST \
                --data "{\"jwt\": \"$JWT_TOKEN\", \"role\": \"demo-role\"}" \
                "$VAULT_ADDR/v1/auth/kubernetes/login")

              CLIENT_TOKEN=$(echo "$LOGIN_RESPONSE" | jq -r '.auth.client_token')
              echo "[*] Vault client token acquired."

              echo "[*] Fetching secrets from Vault..."
              SECRET_RESPONSE=$(curl --silent \
                --header "X-Vault-Token: $CLIENT_TOKEN" \
                "$VAULT_ADDR/v1/kv2/data/react-demo-svc-client")

              client_id=$(echo "$SECRET_RESPONSE" | jq -r '.data.data["client-id"]')
              client_secret=$(echo "$SECRET_RESPONSE" | jq -r '.data.data["client-secret"]')

              echo "[*] Retrieved client_id: $client_id"
              echo "[*] Retrieved client_secret: ****** (hidden for safety)"

              echo "[*] Requesting access token from Keycloak..."
              TOKEN_RESPONSE=$(curl --silent --show-error --fail \
                -X POST "https://identity.agora.gluki.io/realms/gluki/protocol/openid-connect/token" \
                -H "Content-Type: application/x-www-form-urlencoded" \
                --data-urlencode "grant_type=client_credentials" \
                --data-urlencode "client_id=${client_id}" \
                --data-urlencode "client_secret=${client_secret}")

              if echo "$TOKEN_RESPONSE" | jq -e .access_token >/dev/null; then
                access_token=$(echo "$TOKEN_RESPONSE" | jq -r '.access_token')
                echo "[*] Access token extracted successfully."
              else
                echo "[!] Failed to parse access_token from response. Here's the response:"
                echo "$TOKEN_RESPONSE"
                exit 1
              fi

              # Extract the access_token from the response
              access_token=$(echo "$TOKEN_RESPONSE" | jq -r '.access_token')

              # Create Kubernetes secret (replace namespace and secret name as needed)
              SECRET_NAME="react-demo-bearer-token"
              NAMESPACE="default"

              echo "[*] Checking if secret already exists..."
              if kubectl get secret "$SECRET_NAME" -n "$NAMESPACE" >/dev/null 2>&1; then
                echo "[*] Deleting secret: '$SECRET_NAME'"
                kubectl delete secret "$SECRET_NAME" --namespace "$NAMESPACE"
              fi

              echo "[*] Creating secret '$SECRET_NAME'..."
              kubectl create secret generic "$SECRET_NAME" \
                --from-literal=TOKEN="$access_token" \
                --namespace "$NAMESPACE"
              echo "[*] Secret created."

              echo "[*] Job completed successfully."

          volumeMounts:
            - name: projected-sa-token
              mountPath: /vault-token
              readOnly: true
            - name: default-sa-token
              mountPath: /var/run/secrets/kubernetes.io/serviceaccount
              readOnly: true
      volumes:
        - name: projected-sa-token
          projected:
            sources:
              - serviceAccountToken:
                  path: token
                  expirationSeconds: 3600
                  audience: vault
              - configMap:
                  name: kube-root-ca.crt
                  items:
                    - key: ca.crt
                      path: ca.crt
        - name: default-sa-token
          secret:
            secretName: vault-sa-secret
# {{- end }}
